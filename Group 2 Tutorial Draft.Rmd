---
title: "STATS 506 Midterm Project"
author: "[Group2](https://github.com/SkyWang0919/STATS-506-Midterm-Project-02): EunSeon Ahn, Tianshi Wang, Yanyu Long"
date: "November 23, 2020"
output: 
  html_document:
    toc: true
    toc_depth: 2
    highlight: pygments
---

```{css, include = TRUE, echo = FALSE}
body{ /* Normal */
  font-size: 15px;
}
td{ /* Table  */
  font-size: 14px;
}
#TOC{ /* Table of contents */
  font-size: 16px;
}
h2{ /* Header 2 */
  font-size: 28px;
}
h3{ /* Header 3 */
  font-size: 22px;
}
h5{ /* Header 5 */
  font-size: 18px;
  text-decoration: underline;
}
h6{ /* Header 6 */
  font-size: 16px;
  font-weight: bold;
}
.highlight{ /* Highlighted Text */
  background-color: #d8e8e8;
}
span.math{ /* Formulas */
  font-size: 13px;
}
blockquote {
  font-size: 15px;
}
pre { /* Scrollable code block */
  max-height: 300px;
  overflow-y: auto;
}
.plotly{ /* Figures generated with plotly - align center */
  display: block;
  margin-left: auto;
  margin-right: auto;
}
```


```{r setup, include=FALSE}
setwd("E:/git/Stats506_private/group_proj/")
library(tidyverse)
library(reticulate) # for running Python code
library(Statamarkdown) # for running STATA code
knitr::opts_chunk$set(
	echo = TRUE,
	fig.align = "center",
	warning = FALSE,
	message = FALSE,
	include = TRUE,
	engine.path=list(
	  stata='D:/Program Files/StataMP16/StataMP-64.exe',
	  python='D:/Anaconda3/python.exe'
	),
	cleanlog = TRUE # stop STATA code chunks from echoing code
)
stata_pic_lib = "E:/git/Stats506_midterm_project/STATA/"
```


```{python python_setup, include = FALSE}
import os
os.chdir("E:/git/Stats506_midterm_project/")
import pandas as pd
pd.set_option('max_columns', None)
```


```{r html_table_wrapup, echo = FALSE}
format_table = function(table, full_wid = FALSE,
                        collapse_col = NA, ...){
  # specify table format for HTML output file
  # Inputs: 
  #   table - the table to adjust format
  #   full_wid - logical, whether the table will have full width
  #     if FALSE, will set a minimum width of 12em
  #   collapse_col - vector, or NA
  #     if NA, will not collapse rows
  #     if vector, collapse rows for the specified columns if possible
  #   ... - extra parameters to be passed into knitr::kable()
  # Output: the reformatted table
  
  min_wid = ifelse(full_wid, NA, "6em") # minimal width for columns
  table = table %>%
    knitr::kable(
      format = 'html', 
      escape = FALSE, 
      ...
    ) %>%
    kableExtra::row_spec(row = 0, align = "c") %>%
    kableExtra::column_spec(
      column = 1:length(table), 
      width_min = min_wid,
      extra_css = "vertical-align:middle;")
  if (!is.na(collapse_col)){
    table = table %>%
      kableExtra::collapse_rows(columns = collapse_col, valign = "middle")
  }
  table = table %>%
    kableExtra::kable_styling('striped', full_width = full_wid)
  return(table)
}
```
****
# Data Visualization of COVID-19 DATA
## Introduction
Given the high relevance of COVID-19 in 2020 and the impact it has on the vast majority of individuals around the globe, staying informed regarding the current status and spread of COVID around the world has become a daily task for many people. While the severity of the situation necessitates daily monitoring and continuous tracking of the virus, generating enormous amounts of data each day, this also makes it easy for the general population to be overwhelmed by the overabundance of COVID-related data made available from the scientific community. When dealing with such the issue of big datasets, data visualization can serve the critical function of making large data more accessible and comprehensible to the public and the decision makers at large. In our project, we will explore a few of these different graphical concepts that may facilitate a better understanding of the large amounts of information and see how such concepts can turn simple numbers into a relevant narrative. 

In this project, we use datasets from two different sources.  

>*  [The COVID Racial Data Tracker](https://covidtracking.com/race)  
*  [Coronavirus (COVID-19) Hospitalizations & Preventative 
Measures](https://ourworldindata.org/covid-hospitalizations)


**The first dataset**, containing racial and ethnic data on COVID-19 cases in the United States, comes from a collaboration between COVID Tracking Project and Boston University Center for Antiracist Research. 
This racial COVID data include the number of cases and deaths for different races and ethnicities that are reported across all 50 states.
For this first dataset, [marginal histogram]{.highlight} is used to visualize whether COVID-19 affects different races disproportionately across the US.  

**The second dataset** comes from Our World in Data, which gathers COVID-19 data from various government agencies across the globe. 
In addition to reporting more basic measures such as the number of cases, deaths, hospitalization, testing, etc., this dataset also includes social measures such as the government stringency index and the human development index. 
*The government stringency index* is calculated by considering various restrictions the government imposes on the citizens such as wearing a mask in public, workplace closure, international travel ban, etc. 
*The human development index* is calculated by considering various measures of achievement in key dimensions of human development in the country such as life expectancy and standard of living. 

With this dataset, we’ll first demonstrate the usage of bubble plots. 
[Bubble plot]{.highlight} allows plotting of more than 2 variables with the weight or size of the bubble serving as the 3rd axis, and will be used to visualize the relationship between these social measures and the number of COVID-19 deaths in a country. 

Using the same dataset, we’ll also demonstrate how to create an interactive plot. 
[Interactive plot]{.highlight} allows users to manipulate the ways in which the data can be viewed. Some of the ways in which one can interact with the plot may be as simple as being able to zoom in and out of different sections of the plot, include or exclude certain variables in the plot, or click on a particular bar or point to see the actual value. We will walk through the implementation of these mentioned interactive functions into our plots. This interactive plot will be a bar graph showing the number of COVID-19 cases, deaths, hospitalizations, and testing numbers in 5 different Eastern European countries. 

### Software/Tools
In this tutorial, we are using R, STATA, MATLAB and Python to show how these graphical concepts may be implemented.  

Software| Relevant Libraries
------------ | ------------------------------------------------------------
R |  `tidyverse` (manipulation of data), `ggplot2` (plotting), `Cowplot` (plotting), `ggplotly` (adding interactive functionality)
STATA | the built-in command `scatter` and `twoway histogram` used to create the three subplots in marginal plots, and user-written command `grc1leg` is used to combine these subplots into one figure with a command legend. `Scatter` is also used to create the bubble plot. In the extended example of multi-categories histograms, user-written commands `tabcount` (calculate frequency over categories), `bihist` and `byhist` (plotting histograms) are also used. 
Python | `numpy` (manipulation of data) , `pandas` (manipulation of data), `matplotlib` (plotting), `seaborn` (plotting), `plotly` (adding interactive functionality)
MATLAB | `Clickable Legend Toolbox` (adding interactive functionality) and `subaxis` (allow margin adjustment on subplot) from MATLAB File Exchange, `plotly-graphing-library-for-matlab` (adding interactive functionality) from plotly (`bubblechart` requires ). ** NOTE: `bubblechart` function used in plotting bubblechart requires MATLAB_R2020b.



### To-do List  

*  General
    *  Add figure/table captions when appropriate, and make sure 
    they are descriptive
    *  Include references, if any
    *  R & STATA & Python: add more inline comments to help understand the data
*  Marginal plots
    *  Add opening text to briefly describe the motivation to use marginal plots
    *  STATA: Look into the implementation of stacked histogram
    *  MATLAB: Implement marginal plots with `scatterhistogram`
*  Interactive plots
    *  MATLAB: Add a GIF of the interaction
    *  MATLAB: Go into the optional parameter settings for `clickableLegend`

****

## Marginal Histogram {.tabset .tabset-pills}

*  Variables
    *  ID: State & Date
    *  Race
    *  #Cases
    *  #Deaths
*  This figure presents only the **Nov 1, 2020** data.  
*  The Race Data Entry file specifies 9 different racial and ethnicity categories: White, Black, LatinX (Hispanic or Latino), Asian, AIAN (American Indian or Alaska Native), NHPI (Native Hawaiian and Pacific Islander), Multiracial, Other, and Unknown. Since plotting of all those groups would result in a scatterplot that was overcrowded and confusing to interpret, we narrowed down the dataset to only look at 4 different racial groups: White, Black, Asian, and LantinX.  

### R {.tabset}

```{r, eval = FALSE}
# setup
library(tidyverse)
```


##### Reading in and pre-processing the data

```{r plot1_data_prep, class.source = "fold-hide"}
filename_racial = "./data/Race Data Entry - CRDT.csv"
racial_data = read_delim(
  filename_racial, delim = ",",
  col_types = cols(
   .default = col_integer(), 
   Date = col_character(),
   State = col_character()
  )
) %>% 
  pivot_longer(
    cols = starts_with(c("Cases", "Deaths")), 
    names_pattern = "(Cases|Deaths)_(.*)",
    names_to = c(".value", "Race")
  ) %>%
  filter(!str_detect(Race, "Total|Ethnicity"))

date_picked = "20201101"
race_picked = c("White", "Black", "LatinX", "Asian")
plot1_data = racial_data %>%
  filter(
    Date == date_picked, 
    str_detect(Race, paste0(race_picked, collapse = "|"))
  ) %>%
  mutate(
    Race = factor(Race, levels = race_picked, ordered = TRUE)
  )
```

```{r plot1_data_head, echo = FALSE}
plot1_data %>% head(5) %>%
  format_table(align = "cccrr", caption = "Format of `plot1_data`")
```

```{r plot1_na_values, echo = FALSE}
plot1_data %>% 
  summarise(across(.fns = ~sum(is.na(.x)))) %>%
  mutate(across(.fns = ~sprintf("%i/%i", .x, nrow(plot1_data)))) %>%
  format_table(
    align = "c",
    caption = "Number of NA values in `plot1_data`"
  )
```


##### Generating the main plot

```{r plot1_main, fig.height = 3.5, fig.width = 6.5}
plot1_title = sprintf("%s (%s)",
  "Total confirmed COVID-19 deaths vs. cases, U.S. States",
  format(as.Date(date_picked, "%Y%m%d"), "%m/%d/%y")
)

palette_picked = "Set1"

pic1_main = plot1_data %>%
  ggplot(aes(x = Cases, y = Deaths, color = Race)) +
  theme_bw() +
  geom_point(size = 2, alpha = .7) +
  scale_color_brewer(palette = palette_picked) +
  ggtitle(plot1_title) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 12),
    axis.title = element_text(size = 9)
  )

pic1_main
```

##### Creating marginal plots

#### ggExtra::ggMarginal()
```{r plot1_a, fig.height = 4.5, fig.width = 8}
pic1 = pic1_main + 
  theme(legend.position = "left")

ggExtra::ggMarginal(
  pic1, type="histogram", 
  groupColour = TRUE, groupFill = TRUE
)
```

We can create marginal boxplots by setting `type = "boxplot"`: 
```{r plot1_a2, fig.height = 5.5, fig.width = 8}
ggExtra::ggMarginal(
  pic1, type="boxplot", 
  groupColour = TRUE, groupFill = TRUE
)
```

We can also specify the relative size of the main plot to the marginal 
ones using parameter `size`: 

```{r plot1_a3, fig.height = 5.5, fig.width = 8}
ggExtra::ggMarginal(
  pic1, type="boxplot", size = 7,
  groupColour = TRUE, groupFill = TRUE
)
```

A size of 5 means that the main plot is 5x wider and 5x taller than the marginal plots.  
Although `ggMarginal()` provides a easy solution to marginal plots, 
it is not friendly to customization. For example, we cannot set the 
two marginal plots to be of different types or of different sizes. 
Neither can we specify the exact size for marginal plots in 
units such as inch.  
Check out the `Cowplot` section for a more flexible solution to 
creating marginal plots in R. 

#### Cowplot
Using package `Cowplot` to create marginal plots is less succinct, 
but more flexible. Unlike `ggExtra::ggMarginal`, `Cowplot` allows:

*  putting the marginal plots on the left/bottom side of the main image;
*  creating a marginal histogram for one axis, and a box plot/density plot for 
another. 


```{r plot1_b1, fig.align = "default", fig.show = "hold", fig.height = 3, out.width = "50%"}
pic1_xhist = cowplot::axis_canvas(pic1_main, axis = "x") +
  geom_histogram(
    data = plot1_data %>% filter(!is.na(Cases) & !is.na(Deaths)), 
    aes(x = Cases, fill = Race, color = Race),
    bins = 30, alpha = .6
  ) +
  scale_fill_brewer(palette = palette_picked) +
  scale_color_brewer(palette = palette_picked)

pic1_yhist = cowplot::axis_canvas(pic1_main, axis = "y", coord_flip = TRUE) +
  geom_histogram(
    data = plot1_data %>% filter(!is.na(Cases) & !is.na(Deaths)), 
    aes(x = Deaths, fill = Race, color = Race),
    bins = 30, alpha = .6
  ) +
  scale_fill_brewer(palette = palette_picked) +
  scale_color_brewer(palette = palette_picked) +
  coord_flip()

pic1_xhist
pic1_yhist
```

<br>

```{r plot1_b3, fig.height = 4.5, fig.width = 8}
{pic1_main + 
  theme(legend.position = "left")
} %>%
  cowplot::insert_xaxis_grob(
    pic1_xhist, 
    height = grid::unit(.8, "in"), 
    position = "top"
  ) %>%
  cowplot::insert_yaxis_grob(
    pic1_yhist, 
    width = grid::unit(.8, "in"), 
    position = "right"
  ) %>%
  cowplot::ggdraw()
```

##### Marginal plots on the bottom/left side
We can move the marginal plots from the top/right side of the 
original figure to the bottom/left side.  
To do that, we may want to flip the two previously created marginal 
histograms using `scale_y_reverse()`: 

```{r plot1_c1, fig.height = 1.5, fig.width = 3}
pic1_xhist + scale_y_reverse()
```

To make room for the marginal plots, we can move the x-axis and y-axis to the 
top/right side of the original figure by setting the `position` parameter 
in `scale_*_continuous()`: 

```{r plot1_c2, fig.height = 4.5, fig.width = 8}
{pic1_main +
  scale_x_continuous(position = "top") +
  scale_y_continuous(position = "right")
} %>%
  cowplot::insert_xaxis_grob(
    pic1_xhist + scale_y_reverse(), 
    height = grid::unit(.8, "in"), 
    position = "bottom"
  ) %>%
  cowplot::insert_yaxis_grob(
    pic1_yhist + scale_y_reverse(), 
    width = grid::unit(.8, "in"), 
    position = "left"
  ) %>%
  cowplot::ggdraw()
```

##### Marginal plots of different types

```{r plot1_d, fig.height = 4.5, fig.width = 8}
pic1_ybox = cowplot::axis_canvas(pic1_main, axis = "y") +
  geom_boxplot(
    data = plot1_data %>% filter(!is.na(Cases) & !is.na(Deaths)),
    aes(x = 0, y = Deaths, fill = Race, color = Race), 
    alpha = .6
  ) +
  scale_fill_brewer(palette = palette_picked) +
  scale_color_brewer(palette = palette_picked)

{pic1_main + 
  theme(legend.position = "left")
} %>%
  cowplot::insert_xaxis_grob(
    pic1_xhist, 
    height = grid::unit(.8, "in"), 
    position = "top"
  ) %>%
  cowplot::insert_yaxis_grob(
    pic1_ybox, 
    width = grid::unit(.8, "in"), 
    position = "right"
  ) %>%
  cowplot::ggdraw()
```

We can even call `cowplot::insert_yaxis_grob()` twice to add multiple 
margin plots for the y axis (although probably unnecessary).



### STATA

In the STATA example, we will not be using stacked histograms grouped by variable `race` like we do in the other examples. That is because:  

1. generating stacked histograms can be complicated using STATA (we will include a discussion on how to generate histograms with multiple groups  in STATA *right after the tutorial on marginal plots*);
1. stacked histograms generated using command `graph bar` cannot line up with the scatter plot, even if we explicitly set the x,y-axis range to be the same, while simple histograms generated using `twoway histogram` can line up with the scatter plot.


##### Reading in and pre-processing the data

```{stata stata_plot1_data_prep, eval = FALSE}
cd "E:\git\Stats506_midterm_project\STATA\"
import delimited "data\Race Data Entry - CRDT.csv", ///
  stringcols(1) numericcols(3/28) clear

keep if date == "20201101"
keep state *white *black *latinx *asian

reshape long cases_ deaths_, i(state) j(race) string
rename cases_ cases
rename deaths_ deaths

// turn race into a ordered factor
gen race_int = 1
replace race_int = 2 if race == "black"
replace race_int = 3 if race == "latinx"
replace race_int = 4 if race == "asian"

label define race_label 1 "White" 2 "Black" 3 "LatinX" 4 "Asian"
label values race_int race_label 
drop race
rename race_int race

// Drop observations with cases or deaths values being NA
// Keeping these NA values will not affect scatter plot -- either axis being 
// NA, the scatter won't show. But it does affect histograms since they will 
// be based on a single variable (cases or deaths)
drop if cases == . | deaths == .

// categorize deaths (y-axis variable) into four groups by race
separate deaths, by(race) veryshortlabel

save race_plot_data, replace
```

##### Creating marginal plots
We will be Using the user written command `grc1leg` by Vince Wiggins to 
create the marginal plots.  

>grc1leg.  Combine graphs into one graph with a common legend. / Program by
Vince Wiggins, StataCorp <vwiggins@stata.com>. / Statalist distribution,
16 June 2003. / Distribution-Date: 02jun2010

Use the following line to install `grc1leg`:
```{stata, eval = FALSE}
net install grc1leg, from(http://www.stata.com/users/vwiggins/)
```


**Note: **  

> 1.  Run the code chunk from 'local alpha' to 'twoway histogram cases'
at once to make sure the local variables can be used by all three subplots.
1.  The optacity settings (e.g. `mcolor(red%30)`) are only available in 
STATA15 or above. For STATA14 or below, try using hollow circles instead 
of solid ones by adding the option `msymbol(Oh)`.


*  Creating top/right margin plots

```{stata plot1_top_right, eval = FALSE}
use race_plot_data, clear

// set opacity
local alpha %30 
// set x,y-axis limits for both the main plot and the marginal plots
// otherwise the axis scales might differ across the three plots
local xscale_opt xscale(range(0 415000)) 
local yscale_opt yscale(range(0 10500))

// create the main plot
// set color for the four racial groups
local scatter_opt mcolor(red`alpha' blue`alpha' green`alpha' purple`alpha')
scatter deaths? cases, `scatter_opt' ///
  `xscale_opt' `yscale_opt' ///
  legend(subtitle("Race") position(9) cols(1) region(style(none))) ///
  ytitle("Deaths") xtitle("Cases") xlabel(, grid) ///
  saving(yx_tr, replace)

// create the two marginal histograms
local hist_opt color(navy`alpha') bin(30)
twoway histogram deaths, `hist_opt' fraction ///
  `yscale_opt' ysca(alt) horiz fxsize(25) ///
  ytitle("") xlabel(, nogrid) ///
  saving(hy_tr, replace)
twoway histogram cases, `hist_opt' fraction ///
  `xscale_opt' xsca(alt) fysize(25) ///
  xtitle("") xlabel(, grid) ylabel(, nogrid) ///
  saving(hx_tr, replace)

// group the three plots together using 'grc1leg'
// 'colfirst' asks that the three plots will be displayed down column first
// 'legendfrom(yx_tr.gph)' specify using the main plot's legend
// 'position(9)' means putting the legend at 9 o'clock position
local graph_title = "Total confirmed COVID-19 deaths vs. cases, " + ///
                    "U.S. States (11/01/20)"
grc1leg hx_tr.gph yx_tr.gph hy_tr.gph, ///
  colfirst hole(3) imargin(0 0 0 0) ///
  title("`graph_title'", size(medium)) ///
  legendfrom(yx_tr.gph) position(9)
  
// save the final output
graph export stata-marginplot-tr.png, replace

// remove the intermediate files from disk
erase hx_tr.gph
erase yx_tr.gph
erase hy_tr.gph
```

```{r stata_marginal1, echo = FALSE, out.width = '60%'}
pic_name = paste0(stata_pic_lib, "stata-marginplot-tr.png")
if (file.exists(pic_name)){
  knitr::include_graphics(pic_name)
}
```

*  Creating bottom/left margin plots
```{stata plot1_bottom_left, eval = FALSE}
// create the main plot
local alpha %30
local xscale_opt xscale(range(0 415000)) 
local yscale_opt yscale(range(0 10500))

local scatter_opt mcolor(red`alpha' blue`alpha' green`alpha' purple`alpha')
scatter deaths? cases, `scatter_opt' ///
  `xscale_opt' `yscale_opt' ///
  legend(subtitle("Race") position(3) cols(1) region(style(none))) ///
  ytitle("Deaths") xtitle("Cases") ///
  xlabel(, grid) ysca(alt) xsca(alt) /// 
  saving(yx_bl, replace)

// create the two marginal histograms
local hist_opt color(navy%30) bin(30)
twoway histogram deaths, `hist_opt' fraction ///
  `yscale_opt' xsca(alt reverse) horiz fxsize(25) ///
  ytitle("") xlabel(, nogrid) ///
  saving(hy_bl, replace)
twoway histogram cases, `hist_opt' fraction ///
  `xscale_opt' ysca(alt reverse) fysize(25) ///
  xtitle("") xlabel(, grid) ylabel(, nogrid) ///
  saving(hx_bl, replace)

// group the three plots together using 'grc1leg'
// unlike the top-right marginal plot, we do not specify'colfirst' this time
// so that the three plots will be displayed along row first
// legendfrom(yx_bl.gph) specify using the main plot's legend
// position(3) means putting the legend at 3 o'clock position
local graph_title = "Total confirmed COVID-19 deaths vs. cases, " + ///
                    "U.S. States (11/01/20)"
grc1leg hy_bl.gph yx_bl.gph hx_bl.gph, ///
  hole(3) imargin(0 0 0 0) ///
  title("`graph_title'", size(medium)) ///
  legendfrom(yx_bl.gph) position(3)

// save the final output
graph export stata-marginplot-bl.png, replace

// remove the intermediate files from disk
erase hy_bl.gph
erase yx_bl.gph
erase hx_bl.gph

```

```{r stata_marginal2, echo = FALSE, out.width = '60%'}
pic_name = paste0(stata_pic_lib, "stata-marginplot-bl.png")
if (file.exists(pic_name)){
  knitr::include_graphics(pic_name)
}
```

<br>

##### Extension: Generating histograms with multiple groups in STATA

As mentioned above, stacked histograms can be difficult to generate in STATA, and they are not suitable as marginal plots since they cannot properly line up with the main scatter plot.  
However, as an extended example, we will walk through the code to create a stacked histogram of variable `cases` grouped by `race`, using the racial data `race_plot_data.dta` in the marginal plot examples and the `graph bar` command.  

###### Data and summary statistics

```{stata}
cd "E:\git\Stats506_midterm_project\STATA\" 
use race_plot_data, clear
// check out the data format
list state race cases in 1/5
// check out the summary statistics for variable 'cases'
summarize cases
```

###### Creating stacked histogram using graph bar

Since the `graph bar` command is not designed for histograms, we need to manually turn the continuous variable `cases` into intervals and store as a categorical variable `cut_cases`. After that, we can calculate the frequency of each intervals and produce the histogram.  

From the output of `summarize cases`, we know that values of `cases` falls 
in range [74, 401503]. Therefore, we can cut it into 30 intervals from 0 to 402000. 

*Note: since R's library `Statamarkdown` runs each STATA code chunk as an stand-alone .do file, the following code chunks will contain some repetitive code. *  

```{stata}
cd "E:\git\Stats506_midterm_project\STATA\" 
use race_plot_data, clear
// use 'egen ... cut' with option 'at' to turn 'cases' into intervals
egen cut_cases = cut(cases), at(0(13400)402000)
list cases cut_cases in 1/10
```

*Interpretation of `cut_cases`: value 0 represents the range [0, 13400), 
value 13400 represents the range [13400, 26800), etc. *  

We then use `tabcount` to calculate the number of observations for each level of `cut_cases` and `race`. Install `tabcount` using `ssc install tabcount` if you have not already done that. 

```{stata}
cd "E:\git\Stats506_midterm_project\STATA\" 
use race_plot_data, clear
egen cut_cases = cut(cases), at(0(13400)402000)

quietly tabcount cut_cases race, v1(0(13400)402000) v2(1/4) replace
list in 1/20
```

It is important to use `tabcount` here rather than a simple `bysort` command (see the following code chunk). 
`tabcount cut_cases race, v1(0(13400)402000) v2(1/4)` will preserve every intervals of `cases` from [0, 13400) to [388600, 402000), even if there is no observation in that range. To create a histogram, we will need the zero-frequency intervals.  
On the other hand, `bysort` only keeps the levels that actually appear in the dataset (with non-zero frequencies), which means the intervals of cases without data points will not be preserved. 

```{stata}
cd "E:\git\Stats506_private\group_proj\STATA\" 
use race_plot_data, clear
egen cut_cases = cut(cases), at(0(13400)402000)

// DO NOT USE THIS METHOD for the histogram!
bysort cut_cases race: generate freq = _N
keep cut_cases race freq
duplicates drop
list
```

With the frequency table generated using `tabcount`, we can now use command `graph bar (asis) _freq, over(race) over(cut_cases) asyvar stack` to create the stacked histograms. Option `asyvar` asks that the frequencies be stacked over `race` -- the first over() group.  
Since the `tabcount` command with option `replace` will replace the current dataset with the frequency table, we can use the `preserve` and `restore` commands to create a snapshot of the current data and switch back to it later.

```{stata, eval = FALSE}
cd "E:\git\Stats506_private\group_proj\STATA\" 
use race_plot_data, clear
egen cut_cases = cut(cases), at(0(13400)402000)

preserve
quietly tabcount cut_cases race, v1(0(13400)402000) v2(1/4) replace
graph bar (asis) _freq, over(race, sort(race) descending) ///
  over(cut_cases, gap(0) label(nolabels)) asyvar stack
graph export stata-stacked_histogram-graph_bar.png, replace
restore
```

```{r stata_graph_bar, echo = FALSE, out.width = '50%'}
pic_name = "./STATA/stata-stacked_histogram-graph_bar.png"
if (file.exists(pic_name)){
  knitr::include_graphics(pic_name)
}
```

We can further specify the colors for each racial group: 

```{stata, eval = FALSE}
cd "E:\git\Stats506_private\group_proj\STATA\" 
use race_plot_data, clear
egen cut_cases = cut(cases), at(0(13400)402000)

preserve
quietly tabcount cut_cases race, v1(0(13400)402000) v2(1/4) replace
local alpha %40
graph bar (asis) _freq, over(race, sort(race) descending) ///
  over(cut_cases, gap(0) label(nolabels)) asyvar stack ///
  bar(1, color(red`alpha')) bar(2, color(blue`alpha')) ///
  bar(3, color(green`alpha')) bar(4, color(purple`alpha'))
graph export stata-stacked_histogram-graph_bar-colored.png, replace
restore
```

```{r stata_graph_bar_colored, echo = FALSE, out.width = '50%'}
pic_name = "./STATA/stata-stacked_histogram-graph_bar-colored.png"
if (file.exists(pic_name)){
  knitr::include_graphics(pic_name)
}
```

###### Much simpler solutions: bihist & byhist

Apart from the stacked histogram, there are two much simpler methods to add another dimension of information in histograms: (i) using command `bihist` to create histograms with *exactly two categories*; and (ii) using command `byhist` to create interlaced histograms with *two or more categories*.  

These user written commands are designed for histograms, which saves us the trouble of computing frequency over intervals. Therefore, the code is much more succinct and easy to remember. 

Install `bihist` and `byhist` using `ssc install bihist` and `ssc install byhist` if you have not already done that.

```{stata, eval = FALSE}
use race_plot_data, clear
bihist cases if race == 1 | race == 2, by(race)
```

```{r stata_bihist, echo = FALSE, out.width = '50%'}
pic_name = "./STATA/stata-stacked_histogram-bihist.png"
if (file.exists(pic_name)){
  knitr::include_graphics(pic_name)
}
```

```{stata, eval = FALSE}
use race_plot_data, clear
byhist cases, by(race)
```

```{r stata_byhist, echo = FALSE, out.width = '50%'}
pic_name = "./STATA/stata-stacked_histogram-byhist.png"
if (file.exists(pic_name)){
  knitr::include_graphics(pic_name)
}
```


### MATLAB

##### Reading in and pre-processing the data

Prior to any plotting, we'll organize the csv file so it only 
contains the relevant data necessary for plotting.
```{matlab, eval = FALSE}
%% Date Prep 
% Read in data
fileName = 'Race Data Entry - CRDT.csv';
raceData = readtable(fileName);

%Select only 11/01/20 data
newestDate = 20201101;
raceData = raceData(raceData.Date == newestDate,:);

% Convert all case/death # to double
colnames = raceData.Properties.VariableNames;
for i = 3:length(colnames)
    if iscell(raceData.(genvarname(colnames{i})))
        raceData.(genvarname(colnames{i})) = ...
        str2double(raceData.(genvarname(colnames{i})));
    end
end
```

Let's narrow down the dataset to only look at 4 different racial groups: White, Black, Latinx, and Asian since including all available racial categories would provide too much information on a single figure.

```{matlab, eval = FALSE}
%% Get race info
% Grabbing the different races identified in dataset
race_idx = find(contains(colnames, 'Deaths'));
race_idx = race_idx(2 : 10); % remove total and ethnicity info
races = raceData(end, race_idx);
raceID =  strrep(races.Properties.VariableNames, 'Deaths_','');

% selecting relevant columns
plotData = raceData(1 : end, {'Date', 'State', 'Cases_White', ...
    'Cases_Black', 'Cases_LatinX', 'Cases_Asian', 'Deaths_White', ...
    'Deaths_Black', 'Deaths_LatinX', 'Deaths_Asian'});

% reshape case variable for plotting
case_col = startsWith(plotData.Properties.VariableNames, 'Cases');
cases = table2array(plotData(:, case_col));
cases = reshape(cases, [], 1);

% reshape death variable for plotting
death_col = startsWith(plotData.Properties.VariableNames, 'Deaths');
deaths = table2array(plotData(:, death_col));
deaths = reshape(deaths, [], 1);
```

MATLAB's `scatterhist` requires that we pass in a group label that is the same dimension as the x and y datapoints being plotted, so we create a new array, `race_label`, containing matched labels.

```{matlab, eval = FALSE}
% Generate race labels matching the column vector for cases/deaths
race_label = [];
for i = 1 : 4
    race_label = [race_label; repmat(raceID(i), size(raceData,1), 1)];
end
```

##### Creating the marginal plots {.tabset}

###### scatterhist

Now that all the variables are ready, we use the `scatterhist` function to create a scatter plot with histogram plotted along the margins. Here, we specify group label colors to match colors used in R plot. We also specify the location where we want the histograms to be plotted with respect to the scatter plot using argument pair ('Location', 'NorthEast') and the direction that we want the histogram to point by argument pair ('Direction', 'out').

```{matlab, eval = FALSE}
x = cases;
y = deaths;

% Specify color to be used for each race grouping
red = [236, 95, 97] / 255;
blue = [115, 165, 205] / 255;
green = [131, 199, 129] / 255;
purple = [173, 113, 182] / 255;
c_array = [red; blue; green; purple];

figure
% scatterhist does not allow us to adjust the transparency of the plots, 
% to do this we can generate marginal histogram from scratch using subplot
h = scatterhist(x, y, 'Group', race_label, 'Style', 'bar', ...
    'marker', '.', 'Location', 'NorthEast', 'Direction','out', ...
    'color', c_array, 'MarkerSize', 16);

[leg,~] = legend('show');
title(leg,'Race')
xlabel('Cases')
ylabel('Deaths')
sgtitle('Total confirmed COVID-19 deaths vs. cases, U.S. States (11/03/20)') 
```

```{r matlab_marginal1, echo = FALSE, out.width = '70%'}
pic_name = "./Marginal1.png"
if (file.exists(pic_name)){
  knitr::include_graphics(pic_name)
}
```

While the built-in function `scatterhist` is useful for quick plotting because many properties of the figure and the layout do not have to be specified, this function faces the downside of not being able to customize various settings which the user may be looking to specify. Alternatively to `scatterhist `, we may use `subplot` functionality to get around this issue by manually creating a marginal histogram by combining the 3 components (scatterplot + 2 histograms). Please refer to the section 'subplot' for the walkthrough.

######  subplot

In MATLAB, we can also manually create a marginal histogram by arranging together 2 histograms and a scatterplot into a single figure. Because we're working with multiple, separate functions like `hist ` and `scatter` with distinct plot handles for each group, we have much larger customizability of the arranged plots, whereas `scatterhist` prevents users from grabbing all of the figure's property handles and modifying them, like transparency and bin width specific to each histogram. 

We'll be using the toolbox 'subaxis' which builds off the built-in `subplot` functionality in order to minimize the margins between each subplots. This toolbox can be directly downloaded from [link](https://www.mathworks.com/matlabcentral/fileexchange/3696-subaxis-subplot) but it is also included in the repository containing this tutorial. 

```{matlab, eval = FALSE}
addpath('subaxis')
```

Working off the preprocessed data from earlier steps above, we now have to manually plot a histogram for each race and overlay them on top of one another. We do this two times for each of the two histograms (deaths and cases) that's needed for a marginal histogram.

`subaxis` functions allows us to arrange multiple plots into a single figure and additionally allows us to specify the margins surrounding each subplot.

```{matlab, eval = FALSE}
%% Using subplot to create marginal histogram
% breaking race data into separate arrays
white = find(race_label == "White");
black = find(race_label == "Black");
latinx = find(race_label == "LatinX");
asian = find(race_label == "Asian");

```

*  Creating top/right margin plots

```{matlab, eval = FALSE}
figure(1)
clf
% y-data histogram
ah1 = subaxis(2, 2, 4, 'sh', 0, 'sv', 0.01, 'padding', 0, 'margin', 0.1);
p1 = histogram(deaths(white), 'Orientation', 'horizontal', ...
    'Normalization', 'probability', 'BinWidth', 1000, ...
    'Facecolor', red);
hold on
p2 = histogram(deaths(black), 'Orientation', 'horizontal', ...
    'Normalization', 'probability', 'BinWidth', 1000, ...
    'Facecolor', blue);
hold on
p3 = histogram(deaths(latinx), 'Orientation', 'horizontal', ...
    'Normalization', 'probability', 'BinWidth', 1000, ...
    'Facecolor', green);
hold on
p4 = histogram(deaths(asian), 'Orientation', 'horizontal', ...
    'Normalization', 'probability', 'BinWidth', 1000, ...
    'Facecolor', purple);

% x-data histogram
ah2 = subaxis(2, 2, 1,'sh', 0.03, 'sv', 0.03, 'padding', 0, 'margin', 0.1);
histogram(cases(white), 'Normalization', 'probability', ...
    'BinWidth', 20000, 'Facecolor', red)
hold on
histogram(cases(black), 'Normalization', 'probability', ...
    'BinWidth', 20000, 'Facecolor', blue)
hold on
histogram(cases(latinx), 'Normalization', 'probability', ...
    'BinWidth', 20000, 'Facecolor', green)
hold on
histogram(cases(asian), 'Normalization', 'probability', ...
    'BinWidth', 20000, 'Facecolor', purple)
```

The transparency of the scatter points can now be specified because this feature is supported through built-in function `scatter`, using the argument `Markerfacealpha`. I have specified 60% (denoted as 0.6) opacity for all the points. 

```{matlab, eval = FALSE}
% scatterplot
ah3 = subaxis(2, 2, 3, 'sh', 0.03, 'sv', 0.01, ...
    'padding', 0, 'margin', 0.1);
hold on
scatter(cases(white), deaths(white), 'filled', ...
     'MarkerFaceColor', red, 'Markerfacealpha', 0.6)
scatter(cases(black), deaths(black), 'filled', ...
    'MarkerFaceColor', blue, 'Markerfacealpha', 0.6)
scatter(cases(latinx), deaths(latinx), 'filled', ...
    'MarkerFaceColor', green, 'Markerfacealpha', 0.6)
scatter(cases(asian), deaths(asian), 'filled', ...
    'MarkerFaceColor', purple, 'Markerfacealpha', 0.6)
```

We need to remove all the boxes and axes information from the histograms since we're combining them with the scatterplot. Similar to function `scatterhist`'s argument 'Direction' specifying the direction which the histogram plots, `View` property of the subplots can be adjusted to rotate the histograms in the desired direction (commented out in the code below `ah1.View = [180, -90]`). 
Similarly, the arrangement of the subplot is reponsible for specifying the location of the histograms, whether they're to the top or bottom, and left or right of the scatter plot.  

```{matlab, eval = FALSE}
% Remove boxes and axes information from the histogram
linkaxes([ah1, ah3], 'y')
linkaxes([ah3, ah2], 'x')
ah1.Box = 'off';
% ah1.View = [180, -90];
ah1.Visible = 'off';
ah2.Visible = 'off';
ah2.Box = 'off';
% ah2.View = [0, -90];
```

We finish off by creating a single universal legend for all three plots. Since this will not happen automatically when manually plotting and arranging a marginal histogram.

```{matlab, eval = FALSE}
% Create single universal legend
h = [p1;p2;p3;p4];
hold on
lgd = legend(h, 'White', 'Black', 'Latinx', 'Asian');
lgd.Box = 'off';
newPosition = [0.5 0.6 0.13 0.13];
newUnits = 'normalized';
set(lgd, 'Position', newPosition, 'Units', newUnits);
title(lgd, 'Races')

% Give title and label axis in scatterplot
sgtitle('Total confirmed COVID-19 deaths vs. cases, U.S. States (11/03/20)')
xlabel('Cases')
ylabel('Deaths')
```

##### {-}

### Python

```{python plot1_setup, eval = FALSE}
# setup
import numpy as np
import pandas as pd
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt
```


##### Reading in and pre-processing the data

```{python plot1_data, eval = TRUE}
df = pd.read_csv('./Data/Race Data Entry - CRDT.csv')
new = df[df['Date'] == 20201101]
new = new[['Cases_Asian', 'Cases_Black', 'Cases_LatinX','Cases_White',
           'Deaths_Asian', 'Deaths_Black', 'Deaths_LatinX', 'Deaths_White']]
new = new.dropna(axis=0, how='any') # drop all rows that have any NaN values
new.head()
```

##### Creating the marginal plots

*  Plot settings

```{python plot1_plot_setting, eval = FALSE}
left, width = 0.1, 0.65
bottom, height = 0.1, 0.65
spacing = 0.005

x1 = new['Cases_Asian']
y1 = new['Deaths_Asian']
x2 = new['Cases_Black']
y2 = new['Deaths_Black']
x3 = new['Cases_LatinX']
y3 = new['Deaths_LatinX']
x4 = [float(x) for x in new['Cases_White']]
y4 = new['Deaths_White']

rect_scatter = [left, bottom, width, height]
rect_histx = [left, bottom + height + spacing, width, 0.2]
rect_histy = [left + width + spacing, bottom, 0.2, height]

xmax = max(np.max(x1), np.max(x2), np.max(x3))
ymax = max(np.max(y1), np.max(y2), np.max(y3))
binsx = np.arange(0, xmax + 1000, 9000)
binsy = np.arange(0, ymax + 200, 200)
```

*  Creating the marginal plot using `matplotlib`

```{python plot1_script, eval = FALSE}
fig = plt.figure(figsize=(10, 8))
ax = fig.add_axes(rect_scatter)
plt.xlabel('Infectious Number')
plt.ylabel('Death Number')
plt.grid(color='LightGrey')
blue_patch = mpatches.Patch(color='blue', label='Asian')
purple_patch = mpatches.Patch(color='purple', label='Black')
red_patch = mpatches.Patch(color='red', label='LatinX')
green_patch = mpatches.Patch(color='green', label='White')
ax_histx = fig.add_axes(rect_histx, sharex=ax)
ax_histy = fig.add_axes(rect_histy, sharey=ax)
plt.legend(handles=[blue_patch, purple_patch, red_patch, green_patch], loc = 'best')

ax.scatter(x1, y1, color = 'blue', alpha = 0.5)
ax_histx.hist(x1, bins=binsx, color = 'blue', alpha = 0.5)
ax_histy.hist(y1, bins=binsy, orientation='horizontal', color = 'blue', alpha = 0.5)
ax.scatter(x2, y2, color = 'purple', alpha = 0.5)
ax_histx.hist(x2, bins=binsx, color = 'purple', alpha = 0.5)
ax_histy.hist(y2, bins=binsy, orientation='horizontal', color = 'purple', alpha = 0.5)
ax.scatter(x3, y3, color = 'red', alpha = 0.5)
ax_histx.hist(x3, bins=binsx, color = 'red', alpha = 0.5)
ax_histy.hist(y3, bins=binsy, orientation='horizontal', color = 'red', alpha = 0.5)
ax.scatter(x4, y4, color = 'green', alpha = 0.5)
ax_histx.hist(x4, bins=binsx, color = 'green', alpha = 0.5)
ax_histy.hist(y4, bins=binsy, orientation='horizontal', color = 'green', alpha = 0.5)

plt.show()
```


```{r python_marginal, echo = FALSE, out.width = '60%'}
pic_name = "./python_marginal.png"
if (file.exists(pic_name)){
  knitr::include_graphics(pic_name)
}
```

## {- .unlisted .unnumbered}

****

## Bubble plot {.tabset .tabset-pills}

In our project, we use bubble plot to see the relationship between stringency index, human development index, and total # of deaths in each country. Each bubble represents a single country with x-axis measuring the stringency index, y-axis measuring the human development index, and the size of the bubble measuring the total number of deaths in the country at the time of 10/20/20. Bubble plot is useful because it allows us to easily visualize 3 dimensions of the data rather than the conventional 2.  

*  Variables
    *  ID: location(iso_code) & date
    *  continent
    *  total_deaths_per_million
    *  stringency_index (0 - 100, with 100 most strict)
    *  human_development_index (0 - 1, with 1 most developed)
*  This figure presents only the **Oct 20, 2020** data.


### R

```{r, eval = FALSE}
# setup
library(tidyverse)
```


##### Reading in and pre-processing the data

```{r plot2_data_prep, class.source = "fold-hide"}
filename_covid = "./data/owid-covid-data.csv"
plot2_data = read_delim(filename_covid, delim = ",") %>%
  select(date, iso_code, continent, total_deaths_per_million,
         stringency_index, human_development_index) %>%
  filter(date == "2020-10-20")
```

```{r plot2_data_head, echo = FALSE}
plot2_data %>% head(5) %>% 
  format_table(caption = "Format of `plot2_data`")
```

```{r plot2_na_values, echo = FALSE}
plot2_data %>% 
  summarise(across(.fns = ~sum(is.na(.x)))) %>%
  mutate(across(.fns = ~sprintf("%i/%i", .x, nrow(plot2_data)))) %>%
  format_table(
    align = "c",
    caption = "Number of NA values in `plot2_data`"
  )
```

##### Creating the bubble plot
```{r plot2_1, fig.height = 5, fig.width = 8}
plot2_title = paste0(
  "Total #of Deaths Across Gov. Stringency Index", 
  " and Human Development Index"
)

plot2_data %>%
  filter(!is.na(continent)) %>% # remove 'NA' from the plot's legend
  ggplot(aes(x = stringency_index, y = human_development_index,
             size = total_deaths_per_million, color = continent)) +
  theme_bw() +
  geom_point(alpha = .5) +
  scale_size_continuous(
    name = "Total Death (Per Mil.)",
    breaks = seq(100, 1300, 300),
    range = c(2, 14)
  ) +
  scale_color_brewer(
    name = "Continent", 
    palette = "Set1"
  ) +
  scale_x_continuous(
    name = "Stringency Index", 
    breaks = seq(0, 100, 10)
  ) +
  scale_y_continuous(
    name = "Human Development Index",
    breaks = seq(0, 1, 0.1)
  ) +
  ggtitle(plot2_title) +
  theme(
    panel.grid.minor = element_blank(),
    plot.title = element_text(hjust = 0.5, size = 12),
    axis.title = element_text(size = 10)
  ) +
  guides(color = guide_legend(override.aes = list(size = 3))) # enlarge the symbol size in the color legend
```

### STATA

##### Reading in and pre-processing the data
```{stata stata_plot2_data, eval = FALSE}
import delimited "..\Data\owid-covid-data.csv", clear

// keep only relevant variables & data points
keep if date == "2020-10-20"
keep iso_code continent total_deaths_per_million ///
     stringency_index human_development_index
drop if continent == "" //drop international world data points

// drop observations if any of the index measures are missing
drop if stringency_index ==. | ///
        human_development_index==. | ///
		    total_deaths_per_million ==.

save covid_plot_data, replace
```


##### Creating the bubble plot

> **Note: **
The optacity settings (e.g. `mcolor(red%30)`) are only available in 
STATA15 or above. For STATA14 or below, try using hollow circles instead 
of solid ones by adding the option `msymbol(Oh)`.


```{stata, eval = FALSE}
use covid_plot_data, clear

// categorize the human_development_index into six groups by continents
separate human_development_index, by(continent) veryshortlabel

local vars human_development_index? stringency_index ///
      [aw = total_deaths_per_million]
local symbol O // solid circles
local size .75 // make all points smaller (75% of the original size)
local alpha %30
local options xscale(range(0 80)) yscale(range(0.32 1)) ///
			mcolor(red`alpha' blue`alpha' green`alpha' ///
			       purple`alpha' orange`alpha' yellow`alpha') ///
			msymbol(`symbol' `symbol' `symbol' `symbol' `symbol' `symbol') ///
			msize(`size' `size' `size' `size' `size' `size')
local graph_title = ("Total # of Deaths Across Gov. Stringency Index " + ///
                     "and Human Development Index")
scatter `vars', `options' ///
  legend(subtitle("Continent") position(3) cols(1) ///
	       region(style(none))) ///
  title("`graph_title'", size(*.7)) ///
  ytitle("Human Development Index") xtitle("Government Stringency Index") ///
  yscale(titlegap(3)) // enlarge the gap between y-axis title and ticks
                      // to avoid overlap

// save the plot
graph export stata-bubbleplot.png, replace
```

```{r stata_bubble, echo = FALSE, out.width = '60%'}
pic_name = paste0(stata_pic_lib, "stata-bubbleplot.png")
if (file.exists(pic_name)){
  knitr::include_graphics(pic_name)
}
```

### MATLAB
Bubble plot is a relatively new function ([bubblechart](https://www.mathworks.com/help/matlab/ref/bubblechart.html)) introduced to MATLAB in R2020b. We'll need a minimum version of R2020b to be able to run this tutorial.  

##### Reading in and pre-processing the data

```{matlab matlab_plot2_data, eval = FALSE}
%% BubblePlots
% For ref see: https://www.mathworks.com/help/matlab/ref/bubblechart.html

%% Data Prep
fileName = './Data/owid-covid-data.csv';
covid_orig = readtable(fileName);

% Select 2020-10-20 Data
newestDate = datetime([2020  10  20]);
covid = covid_orig(covid_orig.date == newestDate,:);
```

Checking the # of NaN values for the stringency index:  

```{matlab m_plot2_na_stringency, eval = FALSE}
sum(isnan(covid.stringency_index))
```

```{r matlab_plot2_na_stringency, echo = FALSE}
cat("ans = 40")
```

Checking the # of NaN values for the human development index: 

```{matlab matlab_plot2_na_human, eval = FALSE}
sum(isnan(covid.human_development_index))
```

```{r m_plot2_na_human, echo = FALSE}
cat("ans = 33")
```

```{matlab matlab_plot2_variable, eval = FALSE}
% Variables of interest (VOI)
voi = {'location', 'continent', 'total_cases_per_million', ...
       'total_deaths_per_million','stringency_index',...
       'human_development_index'};

% Remove international and world info and keep only variables of interest
covid = covid(1:end-2, voi);
```

We want to group the countries by its continent membership to see if there're any patterns to certain continents being more stringent in COVID-19 restrictions or if certain continents are being impacted more heavily with COVID-19 deaths.  

```{matlab matlab_plot2_label, eval = FALSE}
% Convert continent label to color label to be used in bubble plot
for k = 1 : size(covid, 1)
    if strcmp(covid.continent(k), 'Africa')
       covid.continent{k} = 1;
    elseif strcmp(covid.continent(k), 'Asia')
       covid.continent{k} = 2;
    elseif strcmp(covid.continent(k), 'Europe')
        covid.continent{k} = 3;
    elseif strcmp(covid.continent(k), 'North America')
        covid.continent{k} = 4;
    elseif strcmp(covid.continent(k), 'Oceania')
        covid.continent{k} = 5;
    elseif strcmp(covid.continent(k), 'South America')
        covid.continent{k} = 6;
    end
end

covid = sortrows(covid, 2);

x = table2array(covid(:,5)); % x-axis: Stringency index
y = table2array(covid(:,6)); % y-axis: Human development index
sz = table2array(covid(:,4)); % size: Total deaths per million
c = cell2mat(table2array(covid(:,2))); % color: continent
```


In MATLAB, to create a bubble chart with different grouping colors, different groups have to be plotted separately and then overlaid on top of one another. We can pass in an array of RGB values into `bubblechart` as the third argument to specify the color we want the bubbles to be for each group.

##### Creating the bubble plot

```{matlab matlab_plot2_plot, eval = FALSE}
% Stringency index of countries grouped by continent
x1 = x(c==1); x2 = x(c==2); x3 = x(c==3);
x4 = x(c==4); x5 = x(c==5); x6 = x(c==6);
% Human development index of countries grouped by continent
y1 = y(c==1); y2 = y(c==2); y3 = y(c==3); 
y4 = y(c==4); y5 = y(c==5); y6 = y(c==6);
% Total Deaths per mil. of countries grouped by continent
sz1 = sz(c==1); sz2 = sz(c==2); sz3 = sz(c==3);
sz4 = sz(c==4); sz5 = sz(c==5); sz6 = sz(c==6);

%% Plot data in a tiled chart layout
figure

% colors for plotting
red = [234, 82, 84]/255;
blue = [105, 158, 201]/255;
green = [99, 185, 96]/255;
purple = [177, 122, 186]/255;
orange = [255, 186, 117]/255;
yellow = [255, 255, 153]/255;

t = tiledlayout(1,1);
nexttile
bubblechart(x1, y1, sz1, red) % Africa
hold on
bubblechart(x2, y2, sz2, blue) % Asia
hold on
bubblechart(x3, y3, sz3, green) % Europe
hold on
bubblechart(x4, y4, sz4, purple) % N. America
hold on
bubblechart(x5, y5, sz5, orange) % Oceania
hold on
bubblechart(x6, y6, sz6, yellow) % S. America
hold off

sgtitle('Total # of Deaths Across Gov. Stringency Index and Human Development Index')
xlabel('Stringency Index')
ylabel('Human Development Index')
```

We want to include both the legend for the continents and the legend for the size of the bubbles (`bubblelegend`). In order to include these 2 separate legends, we have to specify a layout for the tile.  

```{matlab matlab_plot2_legend, eval = FALSE}
blgd = bubblelegend('Total Death (Per Mil.)','Location','eastoutside');
lgd = legend('Africa','Asia', 'Europe', 'North America', ...
    'Oceania', 'South America');
title(lgd, 'Continent')
blgd.Layout.Tile = 'east';
lgd.Layout.Tile = 'east';
```

While the default value of the transparency of the bubbles is set at 60% opacity, we'll bring it down to 40% so it's easier to see all the points since we have a large number of data points.

```{matlab matlab_plot2_transparency, eval = FALSE}
b1.MarkerFaceAlpha = 0.4; b2.MarkerFaceAlpha = 0.4;
b3.MarkerFaceAlpha = 0.4; b4.MarkerFaceAlpha = 0.4;
b5.MarkerFaceAlpha = 0.4; b6.MarkerFaceAlpha = 0.4;
```


```{r matlab_bubble1, echo = FALSE, out.width = '70%'}
pic_name = "./bubble1.png"
if (file.exists(pic_name)){
  knitr::include_graphics(pic_name)
}
```

### Python

```{python plot2_setup, eval = FALSE}
# setup
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import seaborn as sns
```


##### Reading in and pre-processing the data

```{python plot2_data, eval = TRUE}
df2 = pd.read_csv("./Data/owid-covid-data.csv")
new2 = df2[df2['date'] == '2020-10-20']
new2 = new2[['continent', 'total_deaths_per_million', 
             'stringency_index', 'human_development_index']]
new2 = new2.dropna(axis=0, how='any')
new2.head()
```

##### Creating the bubble plot {.tabset}

###### Seaborn

```{python plot2_script_seaborn, eval = FALSE}
plt.figure(figsize=(11, 7))
sns.scatterplot(x='stringency_index',
                y='human_development_index',
                size=new2['total_deaths_per_million'],
                sizes=(10,1300),
                alpha=0.6,
                hue=new2['continent'],
                data=new2)

# Put the legend out of the figure
plt.legend(bbox_to_anchor=(1.03, 1),borderaxespad=0,
           prop={'size':12}, handlelength=2,
          frameon=False)
plt.rcParams.update({'legend.labelspacing':1.85})
plt.xlabel('Stringency Index')
plt.ylabel('Human Development Index')
plt.title('Total # of Death Across Stringency Index & Human Development Index')
plt.grid(color='LightGrey')
plt.tight_layout()
plt.savefig("Bubble_plot_Seaborn_color_by_variable_Seaborn_scatterplot.png",
            format='png',dpi=150)
```


```{r python_bubble_seaborn, echo = FALSE, out.width = '70%'}
pic_name = "./python_bubble_seaborn.png"
if (file.exists(pic_name)){
  knitr::include_graphics(pic_name)
}
```

###### Matplotlib

```{python plot2_script_matplotlib, eval = FALSE}
continent_list = ['Africa', 'Asia', 'Europe', 'North America', 'Oceania', 'South America']
color_list = ['red', 'blue', 'green', 'purple', 'gold', 'pink']
colors = {'Africa':'red', 'Asia':'blue', 'Europe':'green',
          'North America':'purple', 'Oceania': 'gold',
          'South America': 'pink'}
l = []
for i in range(6):
    l.append(mpatches.Patch( color=color_list[i],
                             alpha=0.7,
                             label=continent_list[i]))
    
plt.figure(figsize = (9,8))
plt.scatter('stringency_index',
            'human_development_index',
            s='total_deaths_per_million',
            c=new2['continent'].apply(lambda x: colors[x]),
            alpha=0.7,
            data=new2)
plt.grid(color='LightGrey')
plt.xlabel('Stringency Index')
plt.ylabel('Human Development Index')
plt.title('Total # of Death Across Stringency Index & Human Development Index')
legend1 = plt.legend(handles=l, loc = (1.02,0.78))
plt.show()
```


```{r python_bubble_matplotlib, echo = FALSE, out.width = '70%'}
pic_name = "./python_bubble_matplotlib.png"
if (file.exists(pic_name)){
  knitr::include_graphics(pic_name)
}
```

##### {-}

## {- .unlisted .unnumbered}

****

## Interactive plot {.tabset .tabset-pills}
Interactive plots allow us to manipulate the viewing of the data points plotted and can be useful in focusing on specific aspect of the data. 
In this example, we will plot an interactive histogram comparing the # of cases, deaths, tests performed, and hospitalized across a few different countries in Europe ([dataset](https://ourworldindata.org/covid-hospitalizations)). 
Clicking the legend in the plot will either hide or show the bar associated with the specific item in the legend.

*  Variables
    *  ID: location(iso_code) & date
    *  total_cases_per_million
    *  total_deaths_per_million
    *  hosp_patients_per_million
    *  total_tests_per_thousand
*  This figure presents only the **Oct 20, 2020** data.  

### R

```{r, eval = FALSE}
# setup
library(tidyverse)
```

##### Reading in and pre-processing the data

```{r plot3_data_prep, class.source = "fold-hide"}
filename_covid = "./data/owid-covid-data.csv"

variable_list = c(
  "total_cases", "total_deaths", 
  "hosp_patients", "total_tests"
) # this is used to create ordered factor, which will then affect
# the order of variables displayed in the bar plot

plot3_data = read_delim(
  filename_covid, delim = ",",
  col_types = cols(
   date = col_character(),
   iso_code = col_character(),
   location = col_character(),
   total_cases_per_million = col_double(),
   total_deaths_per_million = col_double(),
   hosp_patients_per_million = col_double(),
   total_tests_per_thousand = col_double()
  )
) %>%
  select(date, iso_code, location, 
         total_cases_per_million, 
         total_deaths_per_million,  
         hosp_patients_per_million, 
         total_tests_per_thousand) %>%
  filter(
    iso_code %in% c("AUT", "BEL", "BGR", "CZE", "DNK"),
    date == "2020-10-20"
  ) %>%
  mutate(
    total_tests_per_thousand = total_tests_per_thousand * 1e03
    # turn 'per thousand' to 'per million'
  ) %>%
  pivot_longer(
    cols = total_cases_per_million:total_tests_per_thousand,
    names_pattern = "(.*)_per", 
    names_to = "variable"
  ) %>%
  mutate(
    variable = factor(variable, levels = variable_list, ordered = TRUE)
  )

```

```{r plot3_data_head, echo = FALSE}
plot3_data %>% head(5) %>% 
  format_table(caption = "Format of `plot3_data`")
```

```{r plot3_na_values, echo = FALSE}
plot3_data %>% 
  summarise(across(.fns = ~sum(is.na(.x)))) %>%
  mutate(across(.fns = ~sprintf("%i/%i", .x, nrow(plot3_data)))) %>%
  format_table(
    align = "c",
    caption = "Number of NA values in `plot3_data`"
  )
```

##### Creating the interactive plot
Using library `ggplotly`, we can easily add interactivity to a ggplot 
object, and the interactivity will be retained in an HTML output of 
Rmarkdown.  

Try the following: 

*  Double click an item on the legend to single out that character, 
and double click again to show all characters.
*  Single click an item to hide / re-display that character. 

```{r plot3_1, fig.height = 4, fig.width = 7}
plot3_title = paste0(
  "Comparison of Cases, Deaths, Hospitalizations, and Testing"
)

plot3_base = plot3_data %>%
  ggplot(aes(x = location, y = value,
             fill = variable)) +
  theme_bw() +
  geom_col(position = "dodge", width = .7) +
  scale_fill_brewer(
    name = "Variable", 
    palette = "Paired"
  ) +
  scale_x_discrete(name = "Countries") +
  ggtitle(plot3_title) +
  theme(
    panel.grid.minor = element_blank(),
    plot.title = element_text(hjust = 0.5, size = 12),
    axis.title = element_text(size = 10)
  )

{plot3_base + 
  scale_y_continuous(name = "# per million")} %>%
  plotly::ggplotly()
```

Due to the large data range, we use a log10 scale to transform the y-axis value to ensure all variables of interest are visible.  
Note that when the mouse hovers over a bar, the value presented will still be the original value before scaling. That way we can know the exact value without referencing y-axis labels. 

```{r plot3_2, fig.height = 4, fig.width = 7}
{plot3_base +
  scale_y_continuous(name = "log10(# per million)", trans = "log10") + 
  theme(
    axis.text.y = element_blank() # remove the y-axis label
    # because they are not helpful due to the large data range
  )
} %>%
  plotly::ggplotly()
```

Note that the legend position is higher than static plots. We can 
move the legend items downwards using `plotly::layout()`, and 
move the legend title downwards by (i) hiding the original legend 
title, and (ii) add a new legend title using `plotly::add_annotations`.

```{r plot3_3, fig.height = 4, fig.width = 7}
{plot3_base + 
  scale_y_continuous(name = "log10(# per million)", trans = "log10") +
  theme(
    axis.text.y = element_blank(),
    legend.title = element_blank() # hide the legend title
  )
} %>%
  plotly::ggplotly() %>%
  # move legend downwards
  plotly::layout(legend=list(y=0.8, yanchor="top")) %>% 
  # add the legend title back but to a lower position
  plotly::add_annotations(
    text="Variable",
    xref="paper", x=1.02, xanchor="left",
    yref="paper", y=0.8, yanchor="bottom",
    legendtitle=TRUE,
    showarrow=FALSE
  )
```

### MATLAB

In this tutorial, we'll go over 2 different ways we can introduce interactive feature with MATLAB. 1.) `Clickable Legend Toolbox` is a MATLAB FileExchange toolbox that allows users to hide or unhide data points by clicking on the grouping variable in the legend. 2.) `plotly-graphing-library-for-matlab` is a toolbox written by Plotly distributed through [github](https://github.com/plotly/plotly-graphing-library-for-matlab), allowing MATLAB users to create and export interactive charts in the web brower by incorporating some of the same functionality of Plotly offered in R and Python. However, it should be noted that the functionality built into MATLAB plotly is much more restricted than those available in R and Python. After the preprocessing step, the tutorial will be divided to show these 2 different methods.

##### Reading in and pre-processing the data

```{matlab, eval = FALSE}
%% Data Prep
addpath('clickable_legend')
fileName = 'owid-covid-data.csv';
covid_orig = readtable(fileName);

% Select 2020-10-20 Data
newestDate = covid_orig.date(217);
covid_hosp = covid_orig(covid_orig.date == newestDate,:);
% Keep only countries that have hospitalization data
covid_hosp = covid_hosp(~isnan(covid_hosp.hosp_patients_per_million),:);

% Plotting the following variables:
%   # of deaths, # of cases, # of tests, # hospitalizations
voi = {'location', 'total_cases_per_million', ...
    'total_deaths_per_million','hosp_patients_per_million',...
    'total_tests_per_thousand'};

% Update dataset to only include variables of interest
covid_hosp = covid_hosp(:, voi);
% Convert total_tests_per_thousand to total_tests_per_million
covid_hosp(:,'total_tests_per_thousand') = ...
table(1000*covid_hosp.total_tests_per_thousand);
covid_hosp.Properties.VariableNames{5} = 'total_tests_per_million';
```

##### Creating the interactive plot {.tabset}

###### Clickable Legend

[Clickable Legend Toolbox](https://www.mathworks.com/matlabcentral/fileexchange/21799-clickablelegend-interactive-highlighting-of-data-in-figures) was downloaded from MATLAB FileExchange in order to make the legend interactive. It should be noted that the original toolbox had a small bug associated with a coloring issue in the function (togglevisibility) that had to be corrected. The updated version of the toolbox is available in the [project repository](https://github.com/SkyWang0919/STATS-506-Midterm-Project-02/tree/main/MATLAB/clickable_legend) on github. 

Clickable Legend functionality can be added to any plots that has a multiple groups that can create a legend. In our case, we use bar graphs to compare the number of cases, deaths, hospitalization, and testing across 5 different European countries.
However, it can be added to line plots and scatter plots (by getting rid of the line and specifying marker shape and size).

```{matlab, eval = FALSE}
%% Plotting 
nCountries = 5;
X = categorical(covid_hosp.location(1:nCountries));
Y = [covid_hosp{1:nCountries,2}, covid_hosp{1:nCountries,3},...
    covid_hosp{1:nCountries,4}, covid_hosp{1:nCountries,5}];
figure
bar(X,Y)
```

Once the base plot has been plotted, we add the interactive functionality by calling function 'clickableLegend' and enable the toggling of the visibility of the bars by clicking on the text shown in the legend. In calling the function (`clickableLegend`), we specify the name of each legend entry and the optional location of the legend, through passing argument pair, ('Location', 'eastoutside').

**Note: **The y-axis was log scaled for better comparison of values across different statistics.

```{matlab, eval = FALSE}
clickableLegend({'Case','Death','Hosp','Test'}, 'Location', 'eastoutside');
title('Comparison of Cases, Deaths, Hospitaliations, and Testing')
xlabel('Countries')
ylabel('log10(# per million)')
set(gca, 'YScale', 'log')
```

```{r matlab_interactive, echo = FALSE, out.width = '60%'}
pic_name = "./interactive.png"
if (file.exists(pic_name)){
  knitr::include_graphics(pic_name)
}
```

Unfortunately, MATLAB figure created this way does not retain its interactive functionality through an html export, to see it in action, the example code will have to be executed in MATLAB. The .m script of this code is available in [the project github repository](https://github.com/SkyWang0919/STATS-506-Midterm-Project-02/tree/main/MATLAB).   

######  plotly (MATLAB)

To use plotly for MATLAB, we download the github repository as listed above and add it to our MATLAB path. If this is your first time trying to use plotly on MATLAB, you'll have to run a single line command, `plotlysetup('your_username', 'your_api_key')` with the username and API key that you obtain from plotly website. Further instructions are included in the plotly for matlab github repository.

```{matlab_plotly, eval = FALSE}
addpath('./plotly-graphing-library-for-matlab-master');
```

To create an interactive grouped bar chart, each of the variables being plotted, in our case, # of `cases`, `deaths`, `hospitalizations`, and `tests`, have to be organized into `structs` with options specifying the overall grouping variable (by country), variable name, type of plot (bar). Additional paramters, like the color of the groups can be added to customize the figure.

```{matlab_plotly1, eval = FALSE}
countries = covid_hosp.location(1 : nCountries);
logY = log10(Y);

trace1 = struct(...
  'x', { countries }, ...
  'y', logY(:,1), ...
  'name', 'Total # Cases', ...
  'marker', struct('color', 'rgb(166, 206, 227)'),...
  'type', 'bar');
trace2 = struct(...
  'x', { countries }, ...
  'y', logY(:,2), ...
  'name', 'Total # Deaths', ...
  'marker', struct('color', 'rgb(29, 124, 180)'),...
  'type', 'bar');
trace3 = struct(...
  'x', { countries }, ...
  'y', logY(:,3), ...
  'name', 'Total # Hospitalizations', ...
  'marker', struct('color', 'rgb(178, 223, 138)'),...
  'type', 'bar');
trace4 = struct(...
  'x', { countries }, ...
  'y', logY(:,4), ...
  'name', 'Total # Tested', ...
  'marker', struct('color', 'rgb(52, 164, 44)'),...
  'type', 'bar');
```

We finally combine all of the structs for each variable then pass this combined struct array into yet another struct which puts it all together with other parameters like the title, yaxis, xaxis, legend. With the `plotly` function, we generate the figure (within MATLAB window) and are also provided a url for this figure which is automatically uploaded to your plotly account. 

```{matlab_plotly1, eval = FALSE}
data = {trace1, trace2, trace3, trace4};
layout = struct('title', ...
    'Comparison of # of Cases, Deaths, Hospitalizations, and Testing',...
    'yaxis', struct(...
      'title', 'log10(# per million)'),...
    'xaxis', struct(...
      'title', 'Countries'),...  
    'barmode', 'group', ...
    'legend', struct(...
      'x', 1.0, ...
      'y', 1.0, ...
      'bgcolor', 'rgba(255, 255, 255, 0)', ...
      'bordercolor', 'rgba(255, 255, 255, 0)'));
response = plotly(data, struct('layout', layout, ...
    'filename', 'grouped-bar', 'fileopt', 'overwrite'));
plot_url = response.url;
```

We can then go to the `plot_url` to export the figure as an html figure on top of the figure generated within MATLAB that is already interactive. 

##### {-}

### Python

```{python plot3_setup, eval = FALSE}
# setup
import numpy as np
import plotly.express as px
import plotly.offline as offline
import plotly.graph_objs as go
```


##### Reading in and pre-processing the data
```{python eval = TRUE}
# will be using the same dataset as in the bubble plot section
new3 = df2[df2['date'] == '2020-10-20']
new3 = new3[['location', 'total_cases_per_million', 'total_deaths_per_million',
             'hosp_patients_per_million',  'total_tests_per_thousand']]
new3 = new3.dropna(axis=0, how='any')[0:5]
new3.head()
```


##### Creating the interactive plot

```{python plot3_data, eval = FALSE}
branches = new3['location']
total_cases_per_million = np.log10(new3['total_cases_per_million'])
total_deaths_per_million = np.log10(new3['total_deaths_per_million'])
hosp_patients_per_million = np.log10(new3['hosp_patients_per_million'])
total_tests_per_thousand = np.log10(new3['total_tests_per_thousand']*1000)

trace1 = go.Bar(
   x = branches,
   y = total_cases_per_million,
   name = 'total_cases_per_million'
)
trace2 = go.Bar(
   x = branches,
   y = total_deaths_per_million,
   name = 'total_deaths_per_million'
)
trace3 = go.Bar(
   x = branches,
   y = hosp_patients_per_million,
   name = 'hosp_patients_per_million'
)
trace4 = go.Bar(
   x = branches,
   y = total_tests_per_thousand,
   name = 'total_tests_per_million'
)
data = [trace1, trace2, trace3, trace4]
layout = go.Layout(title = 'Comparison of Cases, Deaths, Hospitalizations, and Testings', barmode = 'group')
fig = go.Figure(data = data, layout = layout)
fig.update_xaxes(title_text='Countries')
fig.update_yaxes(title_text='Log10 (# per million)')
fig.update_layout
offline.plot(fig, filename='interactive.html')
```

```{r python_interactive, echo=FALSE}
htmltools::includeHTML("./ref-PYTHON/interactive.html")
```

## {- .unlisted .unnumbered}

****

## Discussion  

Data visualization can prove to be an immensely useful tool when trying to understand and organize large amounts of data. 
In this tutorial, we reviewed a few graphical concepts, marginal histogram, bubble plot, and interactive plots to demonstrate the functionality of these different graphical concepts and how they may facilitate a better grasp of the pattern captured in the data. 

##### Comparison between different software/tools

The tutorial is carried out in 4 different programming languages (R, STATA, Python, MATLAB). When it comes to data visualization, the two open-source software, [R and Python take the clear lead in flexibility and functionality over the two proprietary languages, STATA and MATLAB]{.highlight}. 
The open-source nature of R and Python has allowed the development of a vast number of user written libraries capable of producing publication quality plots with large customizability of the plots.   

However, at the cost of less customizability on part of the user, [plotting in MATLAB and STATA tends to be a little more succinct and straightforward]{.highlight}, with many default parameters in place that do not need to be specified. We also find that STATA's macros come in really handy when we want to unify settings across multiple figures without writing duplicated code.    

However, we would note that [once we begin to try to implement the same level of specifications in the plots as these open-source software, MATLAB and STATA lose this advantage]{.highlight}. 
For example, with R's ggplot2, we can easily change aesthetic options. 
If we want to enlarge the symbol size in a color legend while keeping the symbols in the main plot untouched, simply using `guides(color = guide_legend(override.aes = list(size = 3)))` will do.
The same task can take much more effort in STATA: we have to create another layer of scatterplot that does not have any valid data points (so the plotting area will be empty) but has larger symbol size (for the legend).  See the [code example](https://www.stata.com/statalist/archive/2009-02/msg01067.html) below:   

```{stata, eval = FALSE}
sysuse auto
twoway /// the 3rd and 4th layers are empty scatter plots with larger msize
    (scatter mpg weight if foreign==0, msymbol(o) mcolor(orange)) ///
    (scatter mpg weight if foreign==1, msymbol(o) mcolor(green))  ///
    (scatter mpg weight if mpg==., msymbol(o) mcolor(orange) msize(*3)) ///
    (scatter mpg weight if mpg==., msymbol(o) mcolor(green)  msize(*3)), ///
    legend(order(3 4) label(3 domestic) label(4 foreign))

```

Python contains a lot of libraries, which allows different implementations of the same plot type. For instance, the bubble plot can be implemented using either `matplotlib` or `Seaborn`. Interestingly, the `matplotlib` package inherits lots of nice properties from MATLAB. Hence it is possible to make plots similar to MATLAB using this package. 

It is a little bit difficult to implement complicated legend in Python using `matplotlib` (e.g. the size legend in the bubble plot). 
The same graph in Python can take more lines of code than using MATLAB. 
It is also worth noting that Python programs become much slower when the data size gets larger.

